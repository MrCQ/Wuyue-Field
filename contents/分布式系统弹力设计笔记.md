# 分布式系统弹力设计笔记

弹力设计又称为容错设计，着眼于分布式系统的各种 “容忍” 能力，包括：

* 容错能力（服务隔离、异步调用、请求幂等性）
* 可伸缩性（有/无状态的服务）
* 一致性（补偿事务，充实机制）
* 应对大流量的能力（熔断、降级）

目标： 在确保系统正确性的基础上，保障系统的可用性

系统可用性度量：

![](https://latex.codecogs.com/gif.latex?Availability%3D%5Cfrac%7BMTTF%7D%7BMTTF%20&plus;MTTR%7D)

* MTTF：Mean Time To Failure 即平均故障前时间，其实也就是正常服务时间，越长越好
* MTTR：Mean Timer To Recovery 即故障修复时间，越短越好

系统可用性标准衡量：

![](https://res.infoq.com/news/2018/03/Left-ear-06-website/zh/resources/3402-1521019466144.png)

既然弹力设计针对的是应对系统各种故障（错误）的能力，那么系统出现各种问题的原因有哪些呢？ 

1. 网络问题：网络故障导致的链接出错，或者网络拥塞等
2. 性能问题：数据库慢查询，Java Full GC，磁盘IO量过大，CPU过高，内存不足
3. 安全问题：网络攻击，如DDOS攻击等
4. 运维问题：系统总是在被更新和修改，架构也在不断地被调整
5. 管理问题：没有梳理出关键服务以及服务的依赖关系，运行信息没有和控制系统同步
6. 硬件问题：硬盘损坏，网卡问题，交换机问题，断电问题


那么面对这些问题，我们能做的是什么？

**将故障处理作为正常功能逻辑加入到系统功能序列，故障时正常且不可预见的**

## 隔离设计

所谓隔离设计，可以理解为系统的”隔板“，当系统出现问题时，问题的影响面不会无限制的延伸，而是会被”隔板“限制在既定范围之内

隔离的方式有哪些呢？

* 服务隔离，也就是常说的微服务，将不同业务模块划分到不同的服务系统中，不同系统之间不存在直接的依赖关系，彼此之间也不存在故障影响关系，如商品服务与用户服务完全独立存在于两套系统中
	* 优势：微服务化之后各个服务之间解耦合，互不影响，在复用程度上也会得到有力提升
	* 劣势：一次批量服务访问的响应时间增加，服务之间的协同任务（数据协同）会变得困难且复杂
* 请求隔离，同一服务针对不同用户群进行对应，即将用户分组，特定用户组访问指定的服务实例，当服务实例出现故障时仅仅影响一部分用户使用，就是所谓的”多租户“模式，
	* 完全独立，即独立的数据与服务
	* 部分独立，独立的数据与共享的服务
	* 完全共享，共享的数据与服务

![](../images/user_isolation.png)

## 异步通讯设计

针对消息通讯机制而言，主要分为同步与异步两类，对于同步调用而言，其会将系统之间耦合与接口，且对于实时性要求也会比异步调用要高

同步调用会存在以下的问题：

* 同步调用中，被调用方的吞吐需要不低于调用方的吞吐
* 调用方将一直等待被调用返回结果
* 同步调用通常是一对一的
* 被调用方出现问题，调用方也会随之出错

在此问题基础上，考虑异步通讯的优势

异步通讯的三种方式：

* 请求响应式，收到请求后直接返回，即收到请求并正在处理中，那么调用方如何拿到结果呢？
	* 调用方轮询，调用方不断尝试询问被调用方的处理结果，知道数据准备好返回结果
	* 调用方注册回调方法，被调用方处理完成后回调请求调用方，典型如支付时候从商家跳转到支付页面，会将回调URL传给支付页面，完成后跳转到该URL
* 订阅方式，接收方订阅发送发的消息，发送方会将订阅消息交由订阅队列处理器发送到订阅方，而发送方并不需要关心消息的处理结果
* Broker方式，发送方与接受方完全解耦，相互不直接联系，而是通过中间Broker完成消息发送与订阅，那么这对Broker提出了很高的要求：
	* 必须是高可用的
	* 必须是高性能且可扩展性好的
	* 必须是持久化的，保证数据不会丢失

三种方式中，前两种方式都存在一定程度上的业务依赖，而第三种方式是完全消除了业务依赖。

上述中的订阅方式与Broker方式，就是**事件驱动模式**，其中最好的便是Broker模式，因为其彻底解除了业务之间的耦合关系。事件驱动存在自身的优势与劣势

![](../images/even-driven-compare.png)

基于Broker模式的异步驱动模型完成异步通讯机制的设计，使得异步通讯能够达到以下效果：

* 业务解耦，各服务之间的业务不直接依赖
* 服务隔离，各服务之间的故障影响不传递
* 性能隔离，各服务之间的吞吐量互不影响
* 流量隔离，利用Broker以消息堆积方式实现”削峰“
* 简便维护，服务独立方便业务维护与扩展工作


## 幂等设计

幂等，通俗来说就是针对于一个方法的执行，执行一次与多次的结果是一样的

为何需要幂等的考量？ 对于各个独立服务而言，服务之间的调用过程（这里一般指的是消息）可能出现三类结果：成功、失败与超时，前两者是明确的，后者是未知的

对于这类未知状态，通常的做法是**重试**，而重试过程可能导致服务在一个处理阶段被多次调用的情况，那么如何消除多次调用的影响称为问题的关键，这也是幂等存在的必要性

如何实现幂等，答案是**全局ID**，也就是为每次调用（通常是消息）指定一个标识 ID，并且这个 ID 是全局唯一的，这个ID可以由中心系统提供，但必须保证是不重复的

Twitter 的开源项目 Snowflake 提供了全局ID的一种实现方式，Redis 和 MongoDB 都提供了全局 ID 生成的实现方式

具体的实现方式：

* 服务接受到消息之后，先将消息记录插入到数据库中
* 若插入成功，则执行消息对应的逻辑处理操作
* 若插入冲突，表示该消息已经被接受处理，则放弃后续操作


## 服务状态

对于分布式系统而言，无状态服务是其设计的最佳实现与铁律，那么系统服务的状态指的是哪些呢？

* 程序调用的结果
* 服务组合的上下文
* 服务的配置

要做出无状态的服务，通常需要将服务的状态转移并保存在第三方，但是带来的副作用是服务与第三方之间出现耦合，且对第三方存储的可用性与扩展性提出了很高的要求



## 补偿事务

从数据库操作角度看，在一个事务当中，出现某个操作失败的时候，当前事务的全部操作影响都应该回滚。类似的，对于业务系统而言，一个业务流程组合了一系列的服务，这些服务过程要不全部执行成功，要不不执行，这就要求当出现错误的时候，或者混滚已完成操作的影响，或者不断重试知道全部服务过程都成功完成。

传统关系型数据库中，事务需要满足**ACID属性**要求：

* 原子性（Atomicity）：整个事务的操作要不全部完成，要不全部不完成
* 一致性（Consistency）：在事务开始之前和结束之后，数据库的完整性约束不会被破坏
* 隔离性（Isolation）：事务之间不会存在相互干扰
* 持久性（Durability）：在事务执行完成之后，事务对数据的修改操作将持久地保存在数据库当中

以上是数据库对于事务的要求，而对于分布式系统而言，对应到此类事务要求的话，很难达到高性能的实际效果。

在分布式系统中，我们知道[CAP理论](https://github.com/MrCQ/Wuyue-Field/blob/master/contents/CAP%20%E7%90%86%E8%AE%BA.md)，但是其最多满足两项要求，为了提升分布式系统的性能，提出了**BASE理论**：

* Basic Availability: 基本可用，即可能出现暂时的不可用状态，但是系统能够及时恢复
* Soft State: 软状态，介于“有状态”和“无状态”的中间状态，即为了提高性能，让服务暂存一些数据和状态，并且这些数据和状态可能不是强一致性的
* Eventual Consistency: 最终一致性，即系统中可能暂时性出现不一致的状态，但是最终都会回到一致状态，因为在网络故障导致分区的情况下，强一致性与可用性之间存在某种程度上的矛盾，最终一致性能够化解这种矛盾

总体来看，BASE理论的出现时允许系统出现暂时性的问题，这样我们系统容错机制设计更具灵活性，因为毕竟故障时在所难免的。基于BASE理论设计系统的特点在于，要保证在短时间内，就算是有数据不同步的风险，我们也应该允许新的交易发生，而后面再业务上将可能出现问题的事务处理掉，以保证最终一致性。

在此理论基础上，如何来做业务补偿呢？

1. 努力将业务执行完成（采用重试机制），过程中涉及到幂等性的保障
2. 监控整个过程的状态，最好是基于工作流引擎完成（？）
3. 业务补偿与业务逻辑强相关，难以通过，充分理解业务，设计回滚的不同状态
4. 下层业务短期预留资源，设置缓冲的业务逻辑，等待事务流程走完

## 重试机制

为什么重试？ 当系统出现故障（执行失败），且认为故障只是暂时的，这个时候需要一定程度的持续尝试，所以选择重试。

当出现暂时性错误时，选择重试，而且每次重试的时间间隔应当呈现出指数级的增长趋势，并设置最大重试次数，不能无限制进行下去。

对此，Spring中专门有一个项目负责重试机制的实现：[Spring Retry](https://github.com/spring-projects/spring-retry)，实例代码如下：

```java

@Service public interface MyService {
	@Retryable(
		value={SQLException.class},
		maxAttempts=2,
		backoff=@Backoff(delay=5000)
	)
	void retryService(String sql) throw SQLException;
	...
}

```

重试机制的关注焦点在于：

* 在什么样的错误下进行重试
* 重试的间隔时间与重试最大次数
* 重试需要有幂等性的设计
* 考虑将重试机制独立于业务代码
* 对于事务，重试不成功还需要进行回滚操作


## 熔断设计

熔断就是“保险丝”，防止程序不断尝试执行可能会失败的操作，同时熔断器也能监控错误的修复状态。熔断器会对判定为故障的服务进行直接错误返回操作，避免对错误服务的持续性触发，并且通过尝试性地透传请求，检测故障的恢复状态。以此，实现对系统故障恢复状态的稳定性保障。

熔断器包括三种状态：

|熔断状态|状态描述|
|------|-------|
|闭合状态|正常调用，当调用失败次数超出了限定时间的失败阈值，则切换到断开状态。设置时钟，一定时间后进入半开状态|
|断开状态|处于该状态时，请求调用会直接返回错误相应，不需要调用后端处理逻辑|
|半开状态|允许一定数量的请求去调用服务，当服务成功返回时，认为服务一倍修复，回到闭合状态|

熔断器的状态切换示意图：

![](https://martinfowler.com/bliki/images/circuitBreaker/state.png)

**引入熔断器之后，可以使系统根据弹力，在系统出现错误并进行修复过程中，更加具备稳定性，减少持续触发错误对系统造成影响**

## 限流设计

限流的目的就是限制并发访问的速度，通常表现为：

* 拒绝服务，把阈值范围外的访问直接丢弃，当出现突发性的流量暴增时，应当拒绝掉流量异常客户端的请求，因为此类请求为不正常或者是恶意的
* 服务降级，关闭或降级部分后端服务，即停止部分优先级低的服务，节省系统资源给优先级高的服务
* 特权请求，资源不足状态下，优先把资源分配给重要客户的处理请求
* 延时处理，通过缓冲队列暂存大量请求，以流量削峰
* 弹性伸缩，以自动化运维对服务进行自动化资源伸缩处理

如何来实现限流呢？ 其实主要的实现思路同计算机网络中的拥塞控制大体类似，方法上具备比较高的参考价值

* 队列算法，通过优先级队列进行流控，队列满则拒绝请求

![](http://pcx7oh21p.bkt.clouddn.com/system/queue-limit.png)

* 漏斗算法，其特点在于经由漏斗发出的请求的速率是匀速的，从实现角度看可采用基于队列的滑动窗口方法（队列限速器），出口速率限制

![](http://pcx7oh21p.bkt.clouddn.com/system/leaky-limit.png)

* 令牌桶算法，令牌桶会按照一定速率生产令牌，只有拿到令牌的请求才能继续后面的流程，相比于漏斗算法，该方法限制的是平均速率，而非瞬时速率。当令牌桶满的时候，是可以承载一次性大爆发流量，空时候速率降至令牌生产速率

![](http://pcx7oh21p.bkt.clouddn.com/system/token-limit.png)

限流最终达到的效果是：

* 保证服务的相应时间与可用性
* 防止多租户下某些组合耗尽资源
* 应对突发流量对系统的影响
* 节约成本，流量峰值是偶发的，资源投入价值不大


## 降级设计

降级设计，即为解决系统资源不足与访问量大的问题，当资源与访问出现矛盾时，为了在有限资源状态下抵抗大量请求的冲击，需要对系统服务进行降级处理，通过牺牲掉一些服务，节省资源保证系统的平稳运行

降级可能需要牺牲掉的：

* 降低一致性，强一致性转为最终一致性，通常是采用缓存的方式，因为缓存能有效降低数据库的压力
* 停止次要功能，停止部分不重要的功能，节省系统资源，比如电商的评论与搜索功能，在抢购场景下意义不大，可暂时停止
* 简化功能，简化业务流程，如不在返回全量数据，而返回部分数据，对于电商场景而言，可由原先返回商品的全量信息，转为只返回商品信息而不包含评论等信息

设计要点：

1. 清楚降级的触发条件，包括吞吐量过大、响应时间满或是失败次数多等
2. 降级影响的功能，哪些是must-have，哪些是nice-to-have，哪些是可以舍弃的


## 总结

服务冗余，即同一服务提供多个副本，具体技术包括：

* 负载均衡 + 服务健康检查： NGINX或HAProxy
* 服务发现 + 动态路由 + 服务健康检查：Consul或Zookeeper
* 自动化运维：Kubernetes

服务解耦与拆分，具体技术包括：

* bulkheads模式： 业务分片、用户分片与数据库拆分
* 自包含系统
* 异步通讯：服务发现、事件驱动、消息队列、业务工作流
* 自动化运维：服务调用链与性能监控

容错设计，具体技术包括：

* 错误处理：重试 + 熔断 + 幂等
* 一致性：强一致性使用两阶段提交、最终一致性采用异步通讯
* 流控：限流 + 降级
* 自动化运维：网关流量调度 + 服务监控

弹力设计大图：

![](http://pcx7oh21p.bkt.clouddn.com/system/sytem-vision.png)

弹力系统开发与运维：

开发选择，[SpringCloud](https://springcloud.cc/) 可作为首选
运维选择，APM 服务监控， Docker+Kubernetes服务调度

对于 SpringCloud 与 Kubernetes，其区别在于：

![](http://pcx7oh21p.bkt.clouddn.com/system/springcloud-kuber.png)

在 Kubernetes 上使用 SpringCloud 可以表现出优异的整体特性，包括有：

![](http://pcx7oh21p.bkt.clouddn.com/system/springcloud+kuber.png)

两个框架工具都值得好好研究一下，MD，又得学了！🤬

END