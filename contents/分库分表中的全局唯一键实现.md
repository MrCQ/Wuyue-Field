# 分库分表中的全局唯一键实现


在单机数据中，主键的实现方式往往是通过数据库自增长方式实现，简单高效，且完全能够保证其唯一性，但是在分库分表中，如果再按照数据库自增长方式的话，势必会造成不同数据库中键值重复的情况，破坏主键唯一性，如何有效实现主键唯一性，是分库分表面临的核心问题之一，本文记录了一些常用的实现方式

## 数据库跳号自增

原理很简单，改变数据库原有的+1自增为跳号自增，例如有3个个库，库1的ID增长方式为0,3,6...，库2的ID增长方式为1,4,7...

该方法的优势在于：

* 简单，由数据库自身控制，不需要代码介入
* 生成的ID是有序的

劣势也很明显，主要是难于扩展，灵活性不够

## UUID 生成

根据机器网卡与当前时间，生成随机数

这种方法的优势在于：

* ID本地生成，简单快捷
* 可扩展性好

劣势主要是：

* 无序
* UUID通常为字符类型，查询效率低

## 本地时间作为键值

读取本地时间，将毫秒值作为键值

优势在于：

* 简单高效，本地完成
* 有序
* ID为整型，查询高效

劣势主要是：

* 高并发下会造成键值重复
* 若机器间的时钟不同步，会造成重复


## Twitter 的 snowflake

snowflack算法用于生成一个long类型的id值：

![](https://gavinlee1.github.io/2017/06/28/%E5%B8%B8%E8%A7%81%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E7%9A%84%E5%AF%B9%E6%AF%94/snowflake.png)

该值构成详解：

* 41 bit 作为毫秒数 - 41 位的长度可以使用 69 年
* 10 bit 作为机器编号 （5 个 bit 是数据中心，5 个 bit 的机器 ID） - 10 位的长度最多支持部署 1024 个节点
* 12 bit 作为毫秒内序列号 - 12 位的计数顺序号支持每个节点每毫秒产生 4096 个 ID 序号

理论上来说每秒内理论上最多可以生成 1000*(2^12)，也就是 400W 的 ID，完全满足业务需求

## Sequence 表辅助

构建一个Sequence辅助表，存放各个库的最新id

|id|name|value|
|---|---|---|
|1|db1|0|
|2|db2|0|

每次生成id，都会到Sequence中找到最新的id，将id+1作为新生成的id值，并且更新回Sequence标（分到的数据库+id值），以此保证id的有序增长，但是该方式存在一个致命缺点，就是每次生成新的id都需要去查询并写入数据库，性能会受到很大影响。

一种改进的方式，锁定Sequence中某个范围的id值，读入内存，每次从内存中拿id，用完以后再次向Sequence表申请锁定下个范围的id值

那么问题来了,如何实现不同数据库的ID全局唯一性呢？

ID = currId * DB_count + DB_Index

DB_count即为数据库数目，currId为当前数据库的最新ID，在单个数据库中以等差序列方式进行ID递增，以此保证不同数据库间的ID全局唯一，其核心在于

参考：

* [常见分布式全局唯一 ID 生成策略及算法的对比](https://gavinlee1.github.io/2017/06/28/%E5%B8%B8%E8%A7%81%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E7%9A%84%E5%AF%B9%E6%AF%94/)