# Java 并发编程

## 并发问题的根源

### 缓存导致可见性的问题

为了平衡CPU与内存之间的速度差异，引入了CPU高速缓存，由于存在缓存，则出现了对于共享变量的访问一致性的问题，一个线程对变量的修改能够在另一线程中及时呈现，这就是所谓的**可见性**

### 线程切换导致原子性的问题

由于IO过程的速度相对于CPU处理过于缓慢，以及为了实现对多种任务的并发执行，现代计算机处理器通常将CPU处理时间进行分片，每个任务处理一定量CPU时间之后进行切换，快速轮换

而由于任务切换带来的成本较高，通常会使用共享内存空间的现成来完成任务的切换工作，通常所说的任务切换指的是线程切换，现在操作系统中，**任务切换可以发生在任务一条CPU指令完成时，而不是程序语句**，

我们把一个或多个操作在CPU执行的过程中不被中断的特性称为**原子性**

### 编译优化带来的有序性的问题

编译优化指的是编译器通过指令重排序等方式来实现性能更优的指令执行，

```java
public class Singleton {
  static Singleton instance;
  static Singleton getInstance(){
    if (instance == null) {
      synchronized(Singleton.class) {
        if (instance == null)
          instance = new Singleton();
        }
    }
    return instance;
  }
}
```

问题可能出在哪儿呢？ 在于 `instance = new Singleton()`，对于类对象初始化的过程可以简单看作：

1. 分配一块内存 M
2. 在内存 M 上初始化 Singleton 对象
3. 将 M 的地址赋给 instance 变量

而经过编译优化之后可能的执行顺序变为了：

1. 分配一块内存 M
2. 将 M 的地址赋给 instance 变量
3. 在内存 M 上初始化 Singleton 对象

这样的话导致的问题是，当线程执行到2时发生了线程切换，另一线程调用getInstance方法时，发现instance变量不为null，执行拿instance返回继续后续过程，进而可能导致空指针等问题

## 内存模型

### 为什么定义Java内存模型？

现代计算机体系大部是采用的对称多处理器的体系架构。每个处理器均有独立的寄存器组和缓存，多个处理器可同时执行同一进程中的不同线程，这里称为处理器的乱序执行。在Java中，不同的线程可能访问同一个共享或共享变量。如果任由编译器或处理器对这些访问进行优化的话，很有可能出现无法想象的问题，这里称为编译器的重排序。除了处理器的乱序执行、编译器的重排序，还有内存系统的重排序。因此Java语言规范引入了Java内存模型，通过定义多项规则对编译器和处理器进行限制，主要是针对可见性和有序性。

### 三个基本原则

* 原子性
* 可见性
* 有序性。

### 内存模型主要内容

锁、volatile字段、final修饰符与对象的安全发布。

1. 锁，锁操作是具备happens-before关系的，解锁操作happens-before之后对同一把锁的加锁操作。实际上，**在解锁的时候，JVM需要强制刷新缓存，使得当前线程所修改的内存对其他线程可见**。
2. volatile字段，volatile字段可以看成是一种不保证原子性的同步但保证可见性的特性，其性能往往是优于锁操作的。但是，频繁地访问 volatile字段也会出现因为不断地强制刷新缓存而影响程序的性能的问题。
3. final修饰符，final修饰的实例字段则是涉及到新建对象的发布问题。当一个对象包含final修饰的实例字段时，其他线程能够看到已经初始化的final实例字段，这是安全的。

### Happens-Before的规则：

1. 程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。
2. 管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而"后面"是指时间上的先后顺序。
3. volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的"后面"同样是指时间上的先后顺序。
4. 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。
5. 线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。
6. 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。
7. 对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始。

Happens-Before的1个特性：传递性。

### Java内存模型底层怎么实现的

主要是通过内存屏障(memory barrier)禁止重排序的，即时编译器根据具体的底层体系架构，将这些内存屏障替换成具体的 CPU 指令。对于编译器而言，内存屏障将限制它所能做的重排序优化。而对于处理器而言，内存屏障将会导致缓存的刷新操作。比如，对于volatile，编译器将在volatile字段的读写操作前后各插入一些内存屏障。


