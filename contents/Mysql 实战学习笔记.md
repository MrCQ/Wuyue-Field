# Mysql 实战学习笔记

## SQL查询是如何执行的

SQL中的查询语句是使用频率最高的SQL命令，当执行一次如`select * from table where id = 10`时究竟发生了什么事情呢？

通常，Mysql 分为 Server 层与存储引擎

Server 层包括连接器，查询缓存，分析器，优化器和执行器等，其涵盖了所有的内置函数（时间、数学等），并且所有的跨存储引擎的功能都在这层实现，如存储过程、触发器和视图等

存储引擎负责数据的存储和提取，其采用插件架构实现模式，支持InnoDB，MyISAM与Memory等存储引擎，从Mysql 5.5.5开始 InnoDB成为默认的存储引擎。

当然，在创建表(create table) 时候可以显示指定存储引擎: engine=InnoDB

整体结构如图所示：

![](../images/query_statement_process.png)


### 连接器

通常我们使用 Mysql Client 连接 Mysql Server，在Server中处理连接的就是连接器

`mysql -h $ip -P $port -u$ user -p`

连接器负责连接验证与鉴权工作，如果连接长期处于空闲状态，连接器会自动断开此连接，默认空闲时间为8小时，由参数wait_timeout控制

一方面，建立连接是一个复杂耗费资源的工作，所以要尽量减少连接建立，倾向于使用长连接

另一方面，mysql执行过程中临时使用的内存是管理在连接对象里面，这部分内存直到连接断开才会被释放，这又与长连接使用矛盾。

通常建议:

* 定期断开长连接
* Mysql 5.7及之后版本，每执行一次大操作后，会通过 mysql_reset_connection 重试初始化连接资源，而不需要重连


### 查询缓存

当执行查询语句时，会优选查询缓存，看是否有该查询语句的缓存记录，缓存通过key-value形式存放在内存中，key是查询语句，value是返回结果

但是，如果表数据有更新，相应的查询缓存也会失效，因此对于更新频繁的表而言，查询缓存往往弊大于利。

从 mysql 8.0 开始，查询缓存整个模块被剔除

### 分析器

如果查询缓存没有命中，则进行分析器阶段，对sql命令进行解析

分析器会把sql语句中的关键词解析出来，如table识别为对应的表，id识别为对应的属性列，这个过程称之为”词法分析“

完成之后进入到”语法分析“，即根据词法分析的结果，按照mysql的语法规则，判断sql语句是否满足mysql的语法。

### 优化器

通过分析器，mysql已经知道了sql语句要做的事情，再经过优化器来决定如何更好地完成这件事情。

例如`mysql> select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;
`
采用先join操作再作条件过滤的方式，或者先条件过滤再join方式都能达到一样的效果，但是对应的执行效率是不一样的，优化器会判断哪种方式效率更优，从而选择更优的实现方式。

### 执行器

分析器知道了做什么事情，优化器知道了如何做这个事情更佳，最后由执行器负责完成

执行器直接对接存储引擎，**首先判断是否拥有该表的权限**，如果有则打开表执行，执行器会根据引擎提供的接口，执行得到查询结果返回

### 疑问总结

* 判断是否有对该表的权限为什么是在执行器完成，而不是之前？

很多时候，SQL语句需要操作的表并不只是SQL字面上那些，比如有个触发器，得在执行器阶段（打开表）才能确定

* 若表T没有字段T，那么执行`select * from T where k=1`时会在什么极端查到异常

分析器阶段，该阶段不仅做了词法分析与语法分析，还会做语义分析

解析器处理语法和解析查询, 生成一课对应的解析树。

预处理器进一步检查解析树的合法。比如: 数据表和数据列是否存在, 别名是否有歧义等。如果通过则生成新的解析树，再提交给优化器

* 分析器做了一次权限验证，执行器又做了一次，区别是什么？

连接器“取”权限，执行器“用”权限


## SQL更新是如何执行的

类似于SQL查询，更新语句也要经过分析器，优化器与执行器等处理流程，不同的是还需要涉及到两个重要的日志模块：redo log (重做日志) 和 binlog (归档日志)

### redo log

更新过程中存在一个问题，如果每次更新操作都要写入磁盘，则每次的更新操作都需要现在磁盘找到该条记录，然后更新，带来的IO与查找成本是相当高的

为了解决这个问题，mysql中提出了write-ahead logging的技术，即，先写日志，再写磁盘。

每当有记录需要更新时，InnoDB会先写到redo log，并更新内存，就算该次更新操作完成，而后InnoDB会在适当的时候将数据写回磁盘

有了 redo log，InnoDB 就可以保证即使数据库发生异常重启后，之前提交的记录不会丢失，这个能力称为crash-safe

### binlog

前面的redo log其实是存储引擎完成的，是引擎层面的日志，而mysql server层也有自己的日志模块，称为binlog

redo log vs. binlog

* redo log是InnoDB引擎特有的，binlog是server层实现的
* redo log是物理日志，记录在某个数据页上做了什么操作；而binlog是逻辑日志，记录的是sql语句的原始逻辑
* redo log大小固定，会循环写（覆盖）；binlog 文件达到一定大小后切换到下一个，不会覆盖

更新过程如下：

![](../images/update_statement_process.png)

注意最后三步，redo log写入过程拆成了两个步骤：prepare 和 commit，这就是**两阶段提交**

### 两阶段提交

两阶段提交存在的意义就是让两份日志之间的逻辑一致

可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的行状态不一致

### 总结

redo log 用于保证 crash-safe 能力。innodb_flush_log_at_trx_commit这个参数设置为1的时候，每次事务的redo log都会持久化到磁盘

sync_binlog 这个参数设置成 1 的时候，表示每次事务的binlog都会持久化到磁盘



### 疑问解答

* 在两阶段过程中发生异常会如何处置？

过程： 1 prepare阶段 2 写binlog 3 commit

当在2之前崩溃时，
重启恢复：后发现没有commit，回滚。备份恢复：没有binlog 。
一致

当在3之前崩溃，
重启恢复：虽没有commit，但满足prepare和binlog完整，所以重启后会自动commit。备份：有binlog，且与redolog一致

* 写redo也是IO操作，也需要耗费性能

Redolog是顺序写，并且可以组提交，还有别的一些优化，收益最大是是这两个因素

* 只有commit完成才算成功，才能提交到数据库吗？

正常情况下需要commit结束才算是完成，但是崩溃恢复过程中是可以接受”redolog处于prepare阶段（写完），且binlog完整（写完）“的情况

* redo log 与 binlog 如何对应上？

通过事务ID

* 如何才能让数据库恢复到今天某一秒的状态

首先找到最近一次全量备份，从备份的时间点开始，取出binlog重放到指定时刻

## 事务隔离

## 索引

## 锁